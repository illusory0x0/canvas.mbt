package "illusory0x0/canvas/canvas"

import(
  "illusory0x0/adapton"
  "illusory0x0/canvas/basic"
  "illusory0x0/canvas/dom"
)

// Values
fn entry() -> Unit

// Types and methods
pub enum Element {
  Layout(@adapton.Thunk[(@basic.Size, Array[(@basic.Vector, Element)])])
  Render(&Renderable)
  Handle(Element, Handler)
}
impl Element {
  add_handler(Self, Handler) -> Self
  hstack(Array[Self], spacing~ : Double) -> Self
  layer(Array[(@basic.Vector, Self)]) -> Self
  layer_(Array[(@adapton.Thunk[@basic.Vector], Self)]) -> Self
  round_border(Self, thickness~ : @adapton.Thunk[Double], color~ : @adapton.Thunk[@basic.Color], radius~ : @adapton.Thunk[Double]) -> Self
  round_padding(Self, thinkness~ : @adapton.Thunk[Double], color~ : @adapton.Thunk[@basic.Color], radius~ : @adapton.Thunk[Double]) -> Self
  size(Self) -> @basic.Size
  spacer(@basic.Size) -> Self
  to_layout_sequence(Self, @basic.Vector) -> Array[(@basic.Vector, Self)]
  to_render_sequence(Self, @basic.Vector) -> Iter[(@basic.Vector, &Renderable)]
  vstack(Array[Self], spacing~ : Double) -> Self
}
impl DepsKind for Element
impl Eq for Element
impl Show for Element

pub struct Handler {
  id : Int
  on_click : (() -> Unit)?
  on_double_click : (() -> Unit)?
  on_mouse_enter : (() -> Unit)?
  on_mouse_leave : (() -> Unit)?
  on_mouse_move : ((@basic.Vector) -> Unit)?
  on_mouse_down : ((@basic.Vector) -> Unit)?
  on_mouse_up : ((@basic.Vector) -> Unit)?
}
impl Handler {
  new(on_click? : () -> Unit, on_double_click? : () -> Unit, on_mouse_enter? : () -> Unit, on_mouse_leave? : () -> Unit, on_mouse_move? : (@basic.Vector) -> Unit, on_mouse_down? : (@basic.Vector) -> Unit, on_mouse_up? : (@basic.Vector) -> Unit) -> Self
}
impl Show for Handler

pub(all) struct Rectangle {
  color : @adapton.Thunk[@basic.Color]
  size : @adapton.Thunk[@basic.Size]
  rnode : &@adapton.Source
}
impl Rectangle {
  new(color~ : @adapton.Thunk[@basic.Color], size~ : @adapton.Thunk[@basic.Size]) -> Self
}
impl DepsKind for Rectangle
impl Renderable for Rectangle

pub(all) struct RoundedBorder {
  color : @adapton.Thunk[@basic.Color]
  size : @adapton.Thunk[@basic.Size]
  radius : @adapton.Thunk[Double]
  thickness : @adapton.Thunk[Double]
  rnode : &@adapton.Source
}
impl RoundedBorder {
  new(color~ : @adapton.Thunk[@basic.Color], size~ : @adapton.Thunk[@basic.Size], radius~ : @adapton.Thunk[Double], thickness~ : @adapton.Thunk[Double]) -> Self
}
impl DepsKind for RoundedBorder
impl Renderable for RoundedBorder

pub(all) struct RoundedRectangle {
  color : @adapton.Thunk[@basic.Color]
  size : @adapton.Thunk[@basic.Size]
  radius : @adapton.Thunk[Double]
  rnode : &@adapton.Source
}
impl RoundedRectangle {
  new(color~ : @adapton.Thunk[@basic.Color], size~ : @adapton.Thunk[@basic.Size], radius~ : @adapton.Thunk[Double]) -> Self
}
impl DepsKind for RoundedRectangle
impl Renderable for RoundedRectangle

pub(all) struct Text {
  color : @adapton.Thunk[@basic.Color]
  size : @adapton.Thunk[@basic.Size]
  text : @adapton.Thunk[String]
  font : @adapton.Thunk[@basic.Font]
  rnode : &@adapton.Source
}
impl Text {
  new(text~ : @adapton.Thunk[String], font~ : @adapton.Thunk[@basic.Font], color~ : @adapton.Thunk[@basic.Color]) -> Self
}
impl DepsKind for Text
impl Renderable for Text

pub struct Window {
  size : @adapton.Cell[@basic.Size]
  dpr : @adapton.Cell[Int]
}
impl Window {
  sync(Self) -> Unit
  sync_from_dom(Self, @dom.Window) -> Unit
}
impl Show for Window

impl Renderable {
  render_iter(@dom.CanvasRenderingContext2D, Iter[(@basic.Vector, &Self)]) -> Unit
}
impl Eq for &Renderable
impl Show for &Renderable

// Type aliases
pub typealias OnClick = () -> Unit

pub typealias OnMouseDown = (@basic.Vector) -> Unit

pub typealias OnMouseEnter = () -> Unit

pub typealias OnMouseLeave = () -> Unit

pub typealias OnMouseMove = (@basic.Vector) -> Unit

pub typealias OnMouseUp = (@basic.Vector) -> Unit

// Traits
pub(open) trait DepsKind {
  render_node(Self) -> &@adapton.Source
  layout_node(Self) -> &@adapton.Source
}

pub(open) trait Renderable : DepsKind {
  size(Self) -> @basic.Size
  render(Self, @basic.Vector, @dom.CanvasRenderingContext2D) -> Unit
}

